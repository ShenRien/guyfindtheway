<style>
  .footer {
    max-width: var(--container-max-size);
    padding: var(--space-7) var(--container-padding-sides);
    margin: var(--space-6) auto 8rem auto;
  }
  .footer a {
    text-decoration: none;
    color: unset;
  }
  .footer a:hover {
    color: var(--color-primary);
    transition: color 0.2s ease-in-out;
  }
  .footer-links {
    list-style: none;
    display: flex;
    align-items: center;
    gap: var(--space-6);
    row-gap: var(--space-4);
    flex-wrap: wrap;
  }
  .link-home {
    font-weight: bold;
    color: var(--color-primary);
    font-size: var(--font-size-lg);
  }
</style>

<footer class="footer">
  <nav>
    <ul class="footer-links">
      <li><a href="{{ '/' | url }}">Home</a></li>
      <li><a href="{{ '/articles' | url }}">Triết học tinh thần</a></li>
      <li><a href="{{ '/tusixmode' | url }}">Tusix mode</a></li>
      <li><a href="{{ '/about' | url }}">About</a></li>
      <li><a href="{{ '/rss' | url }}">RSS</a></li>
    </ul>
  </nav>
</br>
</br>
  <div style='text-align: center; dislplay: flex; align: center; padding-left: 20%;; padding-right: 20%;'>
<div id='cockpit' style='text-align: center;'>
    
    </br>
    <p>Stopwatch</p>
    <div id='display'>00:00:00:00:00</div>
    <p> reset 1 </p>
    <div id='display1'>00:00:00:00:00</div>
<!-- Bạn có thể comment hoặc bỏ comment phần tử display2 mà không ảnh hưởng -->
    <p> Mất dữ liệu </p>
    <div id='display2'>00:00:00:00:00</div>
    <p>Thời gian đã trôi qua kể từ khi nó bắt đầu!</p>
</div>
</div>
<style>
    #display {
        font-size: 1em;
        font-weight: bold;
        margin: 10px;
        color: var(--color-primary);
        font-family: monospace;
    }
    #display1 {
        font-size: 1em;
        font-weight: bold;
        margin: 10px;
        color: var(--color-primary);
        font-family: monospace;
    }
    #display2 {
        font-size: 1em;
        font-weight: bold;
        margin: 10px;
        color: var(--color-primary);
        font-family: monospace;
    }
    #cockpit {
    	background-color: #bfbfbf;
        padding-bottom: 5px;
        border-radius: 10px;
    }
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // ==================== CẤU HÌNH ====================
    const CONFIG = {
        // Định dạng hiển thị: [tên, ngày bắt đầu, padding days]
        timers: [
            { id: 'display', date: new Date(2025, 11, 12, 12, 30, 0), padDays: 3 }, // 12/12/2025 12:30:00
            { id: 'display1', date: new Date(2025, 11, 14, 19, 26, 0), padDays: 3 }, // 14/12/2025 19:26:00
            { id: 'display2', date: new Date(2025, 11, 18, 01, 00, 0), padDays: 3 }  // 18/12/2025 01:00:00
            // Bạn có thể thêm timer mới ở đây, ngay cả khi phần tử HTML chưa tồn tại
        ],
        updateInterval: 100, // ms (100 lần/giây - đủ mượt)
        useAnimationFrame: true, // Sử dụng requestAnimationFrame nếu trình duyệt hỗ trợ
        pauseWhenHidden: true // Tự động dừng khi tab không active
    };

    // ==================== BIẾN TOÀN CỤC ====================
    const MS_PER_SECOND = 1000;
    const MS_PER_MINUTE = MS_PER_SECOND * 60;
    const MS_PER_HOUR = MS_PER_MINUTE * 60;
    const MS_PER_DAY = MS_PER_HOUR * 24;

    let animationId = null;
    let lastUpdateTime = 0;
    const displayElements = {};

    // ==================== HÀM TIỆN ÍCH ====================
    // Format số với padding (nhanh hơn String().padStart)
    function padNumber(num, length) {
        return (num < 0 ? '00' : num.toString()).padStart(length, '0');
    }

    // Tính thời gian từ mili giây -> [days, hours, minutes, seconds, centiseconds]
    function calculateTimeComponents(elapsedMs) {
        const days = Math.floor(elapsedMs / MS_PER_DAY);
        const hours = Math.floor((elapsedMs % MS_PER_DAY) / MS_PER_HOUR);
        const minutes = Math.floor((elapsedMs % MS_PER_HOUR) / MS_PER_MINUTE);
        const seconds = Math.floor((elapsedMs % MS_PER_MINUTE) / MS_PER_SECOND);
        const centiseconds = Math.floor((elapsedMs % MS_PER_SECOND) / 10); // 1/100 giây
        
        return [days, hours, minutes, seconds, centiseconds];
    }

    // Format chuỗi thời gian
    function formatTime(components, padDays = 3) {
        const [days, hours, mins, secs, cs] = components;
        return `${padNumber(days, padDays)}:${padNumber(hours, 2)}:${padNumber(mins, 2)}:${padNumber(secs, 2)}:${padNumber(cs, 2)}`;
    }

    // ==================== HÀM CHÍNH ====================
    function updateAllTimers(timestamp) {
        // Giới hạn tần suất cập nhật (performance throttle)
        if (CONFIG.updateInterval > 0 && timestamp - lastUpdateTime < CONFIG.updateInterval) {
            if (CONFIG.useAnimationFrame) {
                animationId = requestAnimationFrame(updateAllTimers);
            }
            return;
        }
        lastUpdateTime = timestamp;
        
        const now = Date.now(); // Nhanh hơn new Date()
        
        // Cập nhật tất cả timer có phần tử DOM tồn tại
        CONFIG.timers.forEach(timer => {
            const element = displayElements[timer.id];
            if (element) {
                const elapsed = now - timer.date.getTime();
                // Kiểm tra nếu ngày bắt đầu ở tương lai
                if (elapsed < 0) {
                    element.textContent = formatTime([0, 0, 0, 0, 0], timer.padDays);
                    return;
                }
                const timeComponents = calculateTimeComponents(elapsed);
                element.textContent = formatTime(timeComponents, timer.padDays);
            }
        });

        // Lên lịch cập nhật tiếp theo
        if (CONFIG.useAnimationFrame) {
            animationId = requestAnimationFrame(updateAllTimers);
        }
    }

    function startTimers() {
        // Cache tất cả DOM elements chỉ nếu chúng tồn tại
        CONFIG.timers.forEach(timer => {
            const element = document.getElementById(timer.id);
            if (element) {
                displayElements[timer.id] = element;
            } else {
                console.warn(`Phần tử #${timer.id} không tồn tại trong DOM. Timer này sẽ bị bỏ qua.`);
            }
        });

        // Chỉ chạy nếu có ít nhất một timer hợp lệ
        if (Object.keys(displayElements).length === 0) {
            console.error('Không tìm thấy phần tử timer nào để hiển thị!');
            return;
        }

        // Chọn phương thức cập nhật tối ưu
        if (CONFIG.useAnimationFrame && 'requestAnimationFrame' in window) {
            animationId = requestAnimationFrame(updateAllTimers);
        } else {
            // Fallback cho trình duyệt cũ
            updateAllTimers(0);
            setInterval(() => updateAllTimers(Date.now()), CONFIG.updateInterval);
        }
    }

    function stopTimers() {
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
    }

    // ==================== XỬ LÝ SỰ KIỆN ====================
    // Tự động dừng khi tab không active (tiết kiệm pin mobile)
    if (CONFIG.pauseWhenHidden && 'visibilityState' in document) {
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                stopTimers();
            } else {
                startTimers();
            }
        });
    }

    // Xử lý sự kiện trước khi trang đóng
    window.addEventListener('beforeunload', stopTimers);
    window.addEventListener('pagehide', stopTimers);

    // ==================== KHỞI CHẠY ====================
    startTimers();
});
</script>
</footer>
